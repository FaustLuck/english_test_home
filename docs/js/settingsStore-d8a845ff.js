import{B as o,C as d,D as r,E as h}from"./main-de299c61.js";const u=o("settings",{state(){return{dictionary:void 0,limits:void 0,timer:void 0,variants:void 0,isSaved:!0,editingIndex:void 0,editingDifficult:void 0,editingItem:void 0}},actions:{saveSettings(e){Object.assign(this,e)},startEdit({index:e,difficult:t}){Object.assign(this,{editingIndex:e,editingDifficult:t}),this.editingItem={...this.dictionary[t][e]}},clearEdit(){this.editingIndex=null,this.editingDifficult=null,this.editingItem=null},cancelEdit({index:e,difficult:t}){const{oldAnswer:s,oldQuestion:i}=this.dictionary[t][e];this.dictionary[t][e].answer=s,this.dictionary[t][e].question=i,delete this.dictionary[t][e].edited},removeIncluded({index:e,difficult:t}){this.dictionary[t].splice(e,1)},returnDeletedItem({index:e,difficult:t}){let s=this.dictionary[t][e];delete s.excluded},editItem(){const e=this.editingItem;let t=this.dictionary[this.editingDifficult][this.editingIndex];(e==null?void 0:e.oldAnswer)===e.answer&&e.oldQuestion===e.question?(delete e.edited,delete e.oldQuestion,delete e.oldAnswer,t=e):(t.edited=!0,t!=null&&t.oldAnswer||(t.oldAnswer=t.answer),t!=null&&t.oldQuestion||(t.oldQuestion=t.question),Object.assign(t,e))},changeSaved(e){this.isSaved=e,window.onbeforeunload=e?null:()=>!1},async getSettings({sub:e}){const t=await d(`/settings/get/${e}`);Object.assign(this,t)},async addItem({difficult:e,item:t}){this.checkItem({difficult:e,item:t})&&(this.changeSaved(!1),t.included=!0,this.dictionary[e].push(t),this.dictionary[e].sort((i,n)=>i.question<n.question?-1:1))},checkItem({difficult:e,item:t}){return this.dictionary[e].findIndex(i=>i.question===t.question||i.answer===t.answer)===-1},deleteItem({index:e,difficult:t}){this.changeSaved(!1);let s=this.dictionary[t][e];s!=null&&s.included?this.dictionary[t].splice(e,1):s.excluded=!0},saveTimer({timer:e}){this.changeSaved(!1),this.timer=e},saveVariants({variants:e}){this.changeSaved(!1),this.variants=e},saveLimits({difficult:e,limit:t}){this.changeSaved(!1),this.limits[e]=t},async finishEdit(){this.isChanged()&&(this.changeSaved(!1),this.editItem()),this.clearEdit()},isChanged(){const e=this.editingItem,t=this.dictionary[this.editingDifficult][this.editingIndex];return e.question!==t.question||e.answer!==t.answer},async saveChanges(e){const{limits:t,timer:s,variants:i}=this,n=this.assembleChanges();await r("/settings/save",{sub:e,editedDictionary:n,limits:t,timer:s,variants:i}),await this.getSettings({sub:e});const a=await d(`/settings/get/${e}`);this.changeSaved(!0),this.saveSettings(a)},assembleChanges(){let e={};for(let t in this.dictionary){let s=this.dictionary[t].filter(i=>i.included||i.edited||i.excluded);s.length&&(e[t]=s,e[t]=e[t].map(i=>{i!=null&&i.excluded&&(delete i.edited,delete i.included),i!=null&&i.edited&&(delete i.oldAnswer,delete i.oldQuestion);let n=[];return n[0]=i.key??null,(i!=null&&i.included||i!=null&&i.edited)&&n.push(i.question,i.answer),n}))}return e},async sendNewDictionary(e,t){this.changeSaved(!1),await h(e,t)}}});export{u as s};
