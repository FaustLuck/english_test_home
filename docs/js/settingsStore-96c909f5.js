import{C as o,D as h,E as d,G as c}from"./main-5bec4d1c.js";const l=o("settings",{state(){return{dictionary:void 0,limits:void 0,timer:void 0,variants:void 0,isSaved:!0,editingIndex:void 0,editingDifficult:void 0,editingItem:void 0}},actions:{startEdit(e,t){this.dictionary[t][e].excluded||(this.editingIndex=e,this.editingDifficult=t,this.editingItem={...this.dictionary[t][e]})},clearEdit(){this.editingIndex=null,this.editingDifficult=null,this.editingItem=null},cancelEdit(e,t){const{oldAnswer:s,oldQuestion:i}=this.dictionary[t][e];this.dictionary[t][e].answer=s,this.dictionary[t][e].question=i,delete this.dictionary[t][e].edited},removeIncluded(e,t){this.dictionary[t].splice(e,1)},returnDeletedItem(e,t){let s=this.dictionary[t][e];delete s.excluded},editItem(){const e=this.editingItem;let t=this.dictionary[this.editingDifficult][this.editingIndex];(e==null?void 0:e.oldAnswer)===e.answer&&e.oldQuestion===e.question?(delete e.edited,delete e.oldQuestion,delete e.oldAnswer,t=e):(t.edited=!0,t!=null&&t.oldAnswer||(t.oldAnswer=t.answer),t!=null&&t.oldQuestion||(t.oldQuestion=t.question),Object.assign(t,e))},changeSaved(e){this.isSaved=e,window.onbeforeunload=e?null:()=>!1},async getSettings(e){const t=await h(`/settings/get/${e}`);Object.assign(this,t)},async addItem(e,t){this.checkItem(e,t)&&(this.changeSaved(!1),t.included=!0,this.dictionary[e].push(t),this.dictionary[e].sort((i,n)=>i.question<n.question?-1:1))},checkItem(e,t){return this.dictionary[e].findIndex(i=>i.question===t.question||i.answer===t.answer)===-1},deleteItem(e,t){this.changeSaved(!1);let s=this.dictionary[t][e];s!=null&&s.included?this.dictionary[t].splice(e,1):s.excluded=!0},saveTimer(e){this.changeSaved(!1),this.timer=e},saveVariants(e){this.changeSaved(!1),this.variants=e},saveLimits(e,t){this.changeSaved(!1),this.limits[e]=t},async finishEdit(){this.isChanged()&&(this.changeSaved(!1),this.editItem()),this.clearEdit()},isChanged(){const e=this.editingItem,t=this.dictionary[this.editingDifficult][this.editingIndex];return e.question!==t.question||e.answer!==t.answer},async saveChanges(e){const{limits:t,timer:s,variants:i}=this,n=this.assembleChanges();await d("/settings/save",{sub:e,editedDictionary:n,limits:t,timer:s,variants:i}),await this.getSettings(e),this.changeSaved(!0)},assembleChanges(){let e={};for(let t in this.dictionary){let s=this.dictionary[t].filter(i=>i.included||i.edited||i.excluded);s.length&&(e[t]=s,e[t]=e[t].map(i=>{i!=null&&i.excluded&&(delete i.edited,delete i.included),i!=null&&i.edited&&(delete i.oldAnswer,delete i.oldQuestion);let n=[];return n[0]=i.key??null,(i!=null&&i.included||i!=null&&i.edited)&&n.push(i.question,i.answer),n}))}return e},async sendNewDictionary(e,t,s){this.changeSaved(!1),await c(e,t,s),await this.getSettings(s),this.changeSaved(!0)},async sendNewDictionaryFromClipboard(e,t,s){this.changeSaved(!1);const i=this.prepareTable(e),{limits:n,timer:a,variants:r}=this;await d("/settings/save",{sub:s,editedDictionary:i,limits:n,timer:a,variants:r}),await this.getSettings(s),this.changeSaved(!0)},prepareTable(e){var s;let t={};for(const i of e){const n=i[2];(s=t[n])!=null&&s.length||(t[n]=[]),t[n].push([null,i[0],i[1]])}return t}}});export{l as s};
