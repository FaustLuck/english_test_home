import{C as o,D as d}from"./main-2dcca78f.js";const h=o("settings",{state(){return{dictionary:void 0,limits:void 0,timer:void 0,variants:void 0,isSaved:!0,editingIndex:void 0,editingDifficult:void 0,editingItem:void 0}},actions:{saveSettings(t){Object.assign(this,t)},startEdit({index:t,difficult:e}){Object.assign(this,{editingIndex:t,editingDifficult:e}),this.editingItem={...this.dictionary[e][t]}},clearEdit(){this.editingIndex=null,this.editingDifficult=null,this.editingItem=null},cancelEdit({index:t,difficult:e}){const{oldAnswer:s,oldQuestion:i}=this.dictionary[e][t];this.dictionary[e][t].answer=s,this.dictionary[e][t].question=i,delete this.dictionary[e][t].edited},removeIncluded({index:t,difficult:e}){this.dictionary[e].splice(t,1)},returnDeletedItem({index:t,difficult:e}){let s=this.dictionary[e][t];delete s.excluded},editItem(){const t=this.editingItem;let e=this.dictionary[this.editingDifficult][this.editingIndex];(t==null?void 0:t.oldAnswer)===t.answer&&t.oldQuestion===t.question?(delete t.edited,delete t.oldQuestion,delete t.oldAnswer,e=t):(e.edited=!0,e!=null&&e.oldAnswer||(e.oldAnswer=e.answer),e!=null&&e.oldQuestion||(e.oldQuestion=e.question),Object.assign(e,t))},changeSaved(t){this.isSaved=t,window.onbeforeunload=t?null:()=>!1},async getSettings({sub:t}){const e=await d(`getSettings/${t}`,null,"GET");Object.assign(this,e)},async addItem({difficult:t,item:e}){this.checkItem({difficult:t,item:e})&&(this.changeSaved(!1),e.included=!0,this.dictionary[t].push(e),this.dictionary[t].sort((i,n)=>i.question<n.question?-1:1))},checkItem({difficult:t,item:e}){return this.dictionary[t].findIndex(i=>i.question===e.question||i.answer===e.answer)===-1},deleteItem({index:t,difficult:e}){this.changeSaved(!1);let s=this.dictionary[e][t];s!=null&&s.included?this.dictionary[e].splice(t,1):s.excluded=!0},saveTimer({timer:t}){this.changeSaved(!1),this.timer=t},saveVariants({variants:t}){this.changeSaved(!1),this.variants=t},saveLimits({difficult:t,limit:e}){this.changeSaved(!1),this.limits[t]=e},async finishEdit(){this.isChanged()&&(this.changeSaved(!1),this.editItem()),this.clearEdit()},isChanged(){const t=this.editingItem,e=this.dictionary[this.editingDifficult][this.editingIndex];return t.question!==e.question||t.answer!==e.answer},async saveChanges(t){const{limits:e,timer:s,variants:i}=this,n=this.assembleChanges();await d("saveChanges",{sub:t,editedDictionary:n,limits:e,timer:s,variants:i}),await this.getSettings({sub:t});const a=await d(`getSettings/${t}`,null,"GET");this.changeSaved(!0),this.saveSettings(a)},assembleChanges(){let t={};for(let e in this.dictionary){let s=this.dictionary[e].filter(i=>i.included||i.edited||i.excluded);s.length&&(t[e]=s,t[e]=t[e].map(i=>{i!=null&&i.excluded&&(delete i.edited,delete i.included),i!=null&&i.edited&&(delete i.oldAnswer,delete i.oldQuestion);let n=[];return n[0]=i.key??null,(i!=null&&i.included||i!=null&&i.edited)&&n.push(i.question,i.answer),n}))}return t}}});export{h as s};
